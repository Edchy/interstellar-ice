---
import { Icon } from "astro-icon/components";
import Chaos from "./Chaos.astro";
---

<ul class="nav-list-sorry-not-sorry">
  <li class="">
    <a aria-label="github" href="https://github.com/Edchy">
      <Icon name="ri:github-line" size={24} color={"var(--yin)"} />
    </a>
  </li>
  <li class="">
    <a aria-label="github" href="https://github.com/Edchy">
      <Icon name="ri:instagram-line" size={24} color={"var(--yin)"} />
    </a>
  </li>
  <li class="linkedIn-is-a-meme">
    <a aria-label="linkedin" href="https://github.com/Edchy">
      <Icon name="ri:linkedin-line" size={24} color={"var(--yin)"} />
    </a>
  </li>
  <!-- <Chaos /> -->

  <!-- <Icon name="devicon:bun" size={24} color="var(--yin)" /> -->
</ul>

<style>
  ul {
    display: flex;
    flex-direction: column;
    gap: var(--gap-xl);
  }
  .linkedIn-is-a-meme {
    position: relative;
    transition: transform 0.3s
      linear(
        0,
        0.618 4.6%,
        1.072 9.7%,
        1.358 15.3%,
        1.446 18.4%,
        1.497 21.7%,
        1.512 23.9%,
        1.514 26.2%,
        1.481 31.5%,
        1.421 36.4%,
        1.174 53.4%,
        1.108 59.5%,
        1.059 65.7%,
        1.028 71.9%,
        1.009 78.9%,
        1
      );
  }
</style>

<script>
  const linkedInItem = document.querySelector(
    ".linkedIn-is-a-meme"
  ) as HTMLElement;

  // Variables to track user activity
  let lastMoveTime = Date.now();
  let resetTimeout: number | null = null;
  let hasMoved = false;

  // Function to reset position
  const resetPosition = () => {
    linkedInItem.style.transition =
      "transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1)";
    linkedInItem.style.transform = "translate(0, 0)";
    hasMoved = false;
  };

  const getSafeRandomPosition = () => {
    // Get current position (if any)
    let currentX = 0;
    let currentY = 0;

    if (linkedInItem.style.transform) {
      const transform = linkedInItem.style.transform;
      const match = transform.match(
        /translate\((-?\d+\.?\d*)px,\s*(-?\d+\.?\d*)px\)/
      );
      if (match) {
        currentX = parseFloat(match[1]);
        currentY = parseFloat(match[2]);
      }
    }

    // Get viewport dimensions
    const viewportWidth = window.innerWidth;
    const itemRect = linkedInItem.getBoundingClientRect();
    const itemWidth = itemRect.width;

    // Get absolute position of the parent container
    const parentRect = linkedInItem.parentElement?.getBoundingClientRect() || {
      left: 0,
    };
    const offsetLeft = parentRect.left;

    // Calculate maximum safe X (prevent going outside screen to the right)
    const maxSafeX = viewportWidth - offsetLeft - itemWidth - 20;

    // Generate new position that's at least 100px away from current position
    let newX, newY;
    let attempts = 0;

    do {
      // Generate random X that's at least 100px away
      newX =
        Math.random() > 0.5
          ? Math.random() * 100 + 100 // 100 to 200px to the right
          : -Math.random() * 100 - 100; // -100 to -200px to the left

      // If would go beyond right edge, "bounce" it back
      if (newX > maxSafeX) {
        newX = maxSafeX - (newX - maxSafeX); // Reflect back from the edge
      }

      // If would go beyond left edge, bounce it too
      if (newX < -offsetLeft + 20) {
        newX = -offsetLeft + 40; // Bounce away from left edge
      }

      // Generate random Y that's at least 50px away
      newY =
        Math.random() > 0.5
          ? Math.random() * 50 + 50 // 50 to 100px down
          : -Math.random() * 50 - 50; // -50 to -100px up

      // Check if new position is at least 100px away from current position
      const deltaX = newX - currentX;
      const deltaY = newY - currentY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      // If distance is at least 100px, we're good
      if (distance >= 100) {
        break;
      }

      attempts++;
    } while (attempts < 10); // Limit attempts to avoid infinite loop
    // Mark that the element has moved
    hasMoved = true;

    // Reset the timeout if it exists
    if (resetTimeout) {
      clearTimeout(resetTimeout);
      resetTimeout = null;
    }

    // Set a new timeout to reset position after 3 seconds of inactivity
    resetTimeout = window.setTimeout(() => {
      if (Date.now() - lastMoveTime > 3000) {
        resetPosition();
      }
    }, 1000);
    return { x: newX, y: newY };
  };

  // Handle mouseover event - move to random position
  linkedInItem.addEventListener("mouseenter", () => {
    const { x, y } = getSafeRandomPosition();

    // Apply the random position
    linkedInItem.style.transform = `translate(${x}px, ${y}px)`;
  });

  // Also move if mouse gets close
  document.addEventListener("mousemove", (e) => {
    const rect = linkedInItem.getBoundingClientRect();

    // Calculate center of the element
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    // Calculate distance to mouse pointer
    const distX = e.clientX - centerX;
    const distY = e.clientY - centerY;
    const distance = Math.sqrt(distX * distX + distY * distY);

    // Move to random position if mouse gets within 40px
    if (distance < 40) {
      const { x, y } = getSafeRandomPosition();
      linkedInItem.style.transform = `translate(${x}px, ${y}px)`;
    }
  });

  // Recalculate boundaries on window resize
  window.addEventListener("resize", () => {
    // If the element has moved, make sure it's still within boundaries
    if (linkedInItem.style.transform) {
      const { x, y } = getSafeRandomPosition();
      linkedInItem.style.transform = `translate(${x}px, ${y}px)`;
    }
  });
</script>
